"""
Implementation of a state machine and message parsing for the Remote Framebuffer (RFB) protocol as
defined by RFC 6143. The RFB protocol is commonly used in VNC (Virtual Network Computing) systems
for remote desktop sharing.

This implementation was developed to parse messages generated by x11vnc (libvncserver) <-> noVNC.

 - [noVNC](https://github.com/novnc/noVNC) is a web based VNC client with a easy to follow
   implementation.
 - [libvncserver](https://github.com/LibVNC/libvncserver) is a C library allowing one to implement
   VNC server or client functionality. This is used by x11vnc to expose a X11 display as a VNC
   server.

Many extensions to the protocol are not supported and using different servers / clients may not
work. However support should be easy to add as needed.

References

 - The Remote Framebuffer (RFB) protocol is defined by
   [RFC6143](https://datatracker.ietf.org/doc/html/rfc6143)
 - However, there are MANY extensions not documented in the RFC.
   A more comprehensive reference is
   https://github.com/rfbproto/rfbproto/blob/master/rfbproto.rst
"""

from __future__ import annotations

from collections.abc import Iterable, Mapping
from dataclasses import dataclass, field
from enum import Enum, Flag
from struct import Struct
from typing import IO, Any, ClassVar, Self

from .keysymdef import X11Key

__all__ = [
    # Client Messages
    "ClientMessage",
    "ClientMessageKind",
    "SetPixelFormat",
    "SetEncodings",
    "FramebufferUpdateRequest",
    "KeyEvent",
    "PointerEvent",
    "MouseButtons",
    "ClientCutText",
    "parse_client_message",
    # Server Messages
    "ServerMessage",
    "ServerMessageKind",
    "FramebufferUpdate",
    "SetColorMapEntries",
    "Bell",
    "ServerCutText",
    "parse_server_message",
    # Server Messages: FramebufferUpdate rect types
    "FramebufferUpdateRect",
    "Rectangle",
    "RawRect",
    "CopyRect",
    "PseudoCursorRect",
    "PseudoExtendedDesktopSizeRect",
    "PseudoLastRect",
    "PseudoQemuExtendedKeyEventRect",
    "PseudoQemuLedStateRect",
    "TightRect",
    "TightRectContent",
    "TightRectFill",
    "TightRectCopyFilter",
    "TightRectJpeg",
    "TightRectPaletteFilter",
    # Handshake Messages
    "ProtocolVersion",
    "SecurityType",
    "ServerSecurity",
    "ServerSecurityResult",
    "ClientInit",
    "ServerInit",
    "PixelFormat",
    "Encoding",
]

#    ____ _ _            _     __  __
#   / ___| (_) ___ _ __ | |_  |  \/  | ___  ___ ___  __ _  __ _  ___  ___
#  | |   | | |/ _ \ '_ \| __| | |\/| |/ _ \/ __/ __|/ _` |/ _` |/ _ \/ __|
#  | |___| | |  __/ | | | |_  | |  | |  __/\__ \__ \ (_| | (_| |  __/\__ \
#   \____|_|_|\___|_| |_|\__| |_|  |_|\___||___/___/\__,_|\__, |\___||___/
#                                                         |___/


class ClientMessageKind(Enum):
    """
    https://datatracker.ietf.org/doc/html/rfc6143#section-7.5

    The client-to-server message types defined in this document are:

                    +--------+--------------------------+
                    | Number | Name                     |
                    +--------+--------------------------+
                    | 0      | SetPixelFormat           |
                    | 2      | SetEncodings             |
                    | 3      | FramebufferUpdateRequest |
                    | 4      | KeyEvent                 |
                    | 5      | PointerEvent             |
                    | 6      | ClientCutText            |
                    | 255    | QEMU Client Message      |
                    +--------+--------------------------+

    Other message types exist but are not publicly documented.  Before
    sending a message other than those described in this document, a
    client must have determined that the server supports the relevant
    extension by receiving an appropriate extension-specific confirmation
    from the server.
    """

    SET_PIXEL_FORMAT = 0
    SET_ENCODINGS = 2
    FRAMEBUFFER_UPDATE_REQUEST = 3
    KEY_EVENT = 4
    POINTER_EVENT = 5
    CLIENT_CUT_TEXT = 6
    QEMU = 255


@dataclass(frozen=True)
class SetPixelFormat:
    """
    https://datatracker.ietf.org/doc/html/rfc6143#section-7.5.1

    A SetPixelFormat message sets the format in which pixel values should
    be sent in FramebufferUpdate messages.  If the client does not send a
    SetPixelFormat message, then the server sends pixel values in its
    natural format as specified in the ServerInit message
    (Section 7.3.2).


    If true-color-flag is zero (false), then this indicates that a "color
    map" is to be used.  The server can set any of the entries in the
    color map using the SetColorMapEntries message (Section 7.6.2).
    Immediately after the client has sent this message, the contents of
    the color map are undefined, even if entries had previously been set
    by the server.

               +--------------+--------------+--------------+
               | No. of bytes | Type [Value] | Description  |
               +--------------+--------------+--------------+
               | 1            | U8 [0]       | message-type |
               | 3            |              | padding      |
               | 16           | PIXEL_FORMAT | pixel-format |
               +--------------+--------------+--------------+
    """

    pixel_format: PixelFormat

    @classmethod
    def from_bytes(cls, message: IO[bytes]) -> Self:
        _read_exactly(message, 3)  # padding
        return cls(PixelFormat.from_bytes(message))

    def to_bytes(self) -> bytes:
        header = Struct("bxxx").pack(ClientMessageKind.SET_PIXEL_FORMAT.value)
        return header + self.pixel_format.to_bytes()


@dataclass(frozen=True)
class SetEncodings:
    """
    https://datatracker.ietf.org/doc/html/rfc6143#section-7.5.2

    A SetEncodings message sets the encoding types in which pixel data
    can be sent by the server.  The order of the encoding types given in
    this message is a hint by the client as to its preference (the first
    encoding specified being most preferred).  The server may or may not
    choose to make use of this hint.  Pixel data may always be sent in
    raw encoding even if not specified explicitly here.

    In addition to genuine encodings, a client can request "pseudo-
    encodings" to declare to the server that it supports certain
    extensions to the protocol.  A server that does not support the
    extension will simply ignore the pseudo-encoding.  Note that this
    means the client must assume that the server does not support the
    extension until it gets some extension-specific confirmation from the
    server.

    See Section 7.7 for a description of each encoding and Section 7.8
    for the meaning of pseudo-encodings.

            +--------------+--------------+---------------------+
            | No. of bytes | Type [Value] | Description         |
            +--------------+--------------+---------------------+
            | 1            | U8 [2]       | message-type        |
            | 1            |              | padding             |
            | 2            | U16          | number-of-encodings |
            +--------------+--------------+---------------------+

    This is followed by number-of-encodings repetitions of the following:

               +--------------+--------------+---------------+
               | No. of bytes | Type [Value] | Description   |
               +--------------+--------------+---------------+
               | 4            | S32          | encoding-type |
               +--------------+--------------+---------------+
    """

    encodings: tuple[Encoding, ...]

    _STRUCT_NO_TAG: ClassVar[Struct] = Struct("!xH")
    _STRUCT_WITH_TAG: ClassVar[Struct] = Struct("!BxH")

    @classmethod
    def from_bytes(cls, message: IO[bytes]) -> Self:
        (num_encodings,) = _unpack_stream(cls._STRUCT_NO_TAG, message)
        encodings_s32 = _unpack_stream(Struct(f"!{num_encodings}l"), message)

        # Handle unknown encodings gracefully - skip those we don't support
        supported_encodings = []
        for encoding_value in encodings_s32:
            try:
                supported_encodings.append(Encoding(encoding_value))
            except ValueError:
                # Log but ignore unsupported encodings
                import logging

                logging.getLogger("vnc.rfb_messages").debug(
                    f"Ignoring unsupported encoding: {encoding_value}"
                )
                continue

        return cls(tuple(supported_encodings))

    def to_bytes(self) -> bytes:
        header = self._STRUCT_WITH_TAG.pack(
            ClientMessageKind.SET_ENCODINGS.value,
            len(self.encodings),
        )
        encodings = Struct(f"!{len(self.encodings)}l").pack(
            *(encoding.value for encoding in self.encodings)
        )
        return header + encodings


@dataclass(frozen=True)
class FramebufferUpdateRequest:
    """
    https://datatracker.ietf.org/doc/html/rfc6143#section-7.5.3

    A FramebufferUpdateRequest message notifies the server that the
    client is interested in the area of the framebuffer specified by
    x-position, y-position, width, and height.  The server usually
    responds to a FramebufferUpdateRequest by sending a
    FramebufferUpdate.  A single FramebufferUpdate may be sent in reply
    to several FramebufferUpdateRequests.

    The server assumes that the client keeps a copy of all parts of the
    framebuffer in which it is interested.  This means that normally the
    server only needs to send incremental updates to the client.

    If the client has lost the contents of a particular area that it
    needs, then the client sends a FramebufferUpdateRequest with
    incremental set to zero (false).  This requests that the server send
    the entire contents of the specified area as soon as possible.  The
    area will not be updated using the CopyRect encoding.

    If the client has not lost any contents of the area in which it is
    interested, then it sends a FramebufferUpdateRequest with incremental
    set to non-zero (true).  If and when there are changes to the
    specified area of the framebuffer, the server will send a
    FramebufferUpdate.  Note that there may be an indefinite period
    between the FramebufferUpdateRequest and the FramebufferUpdate.

    In the case of a fast client, the client may want to regulate the
    rate at which it sends incremental FramebufferUpdateRequests to avoid
    excessive network traffic.

               +--------------+--------------+--------------+
               | No. of bytes | Type [Value] | Description  |
               +--------------+--------------+--------------+
               | 1            | U8 [3]       | message-type |
               | 1            | U8           | incremental  |
               | 2            | U16          | x-position   |
               | 2            | U16          | y-position   |
               | 2            | U16          | width        |
               | 2            | U16          | height       |
               +--------------+--------------+--------------+
    """

    incremental: bool  # u8
    x: int  # u16
    y: int  # u16
    width: int  # u16
    height: int  # u16

    _STRUCT_NO_TAG: ClassVar[Struct] = Struct("!BHHHH")
    _STRUCT_WITH_TAG: ClassVar[Struct] = Struct("!BBHHHH")

    @classmethod
    def read_from(cls, message: IO[bytes]) -> Self:
        incremental, x, y, width, height = _unpack_stream(cls._STRUCT_NO_TAG, message)

        return cls(
            incremental=incremental != 0,
            x=x,
            y=y,
            width=width,
            height=height,
        )

    def to_bytes(self) -> bytes:
        return self._STRUCT_WITH_TAG.pack(
            ClientMessageKind.FRAMEBUFFER_UPDATE_REQUEST.value,
            int(self.incremental),
            self.x,
            self.y,
            self.width,
            self.height,
        )


@dataclass(frozen=True)
class KeyEvent:
    """
    https://datatracker.ietf.org/doc/html/rfc6143#section-7.5.4

    A KeyEvent message indicates a key press or release.  Down-flag is
    non-zero (true) if the key is now pressed, and zero (false) if it is
    now released.  The key itself is specified using the "keysym" values
    defined by the X Window System, even if the client or server is not
    running the X Window System.

               +--------------+--------------+--------------+
               | No. of bytes | Type [Value] | Description  |
               +--------------+--------------+--------------+
               | 1            | U8 [4]       | message-type |
               | 1            | U8           | down-flag    |
               | 2            |              | padding      |
               | 4            | U32          | key          |
               +--------------+--------------+--------------+

    For most ordinary keys, the keysym is the same as the corresponding
    ASCII value.  For full details, see [XLIBREF] or see the header file
    <X11/keysymdef.h> in the X Window System distribution.
    """

    key: X11Key  # u32
    is_down: bool  # u8

    _STRUCT_NO_TAG: ClassVar[Struct] = Struct("!BxxI")
    _STRUCT_WITH_TAG: ClassVar[Struct] = Struct("!BBxxI")

    @classmethod
    def from_bytes(cls, message: IO[bytes]) -> Self:
        is_down, key = _unpack_stream(cls._STRUCT_NO_TAG, message)
        return cls(
            key=X11Key(key),
            is_down=is_down != 0,
        )

    def to_bytes(self) -> bytes:
        return self._STRUCT_WITH_TAG.pack(
            ClientMessageKind.KEY_EVENT.value,
            self.is_down,
            self.key.value,
        )

    @classmethod
    def from_dict(cls, event_dict: Mapping[str, int]) -> Self:
        match event_dict:
            case {
                "key": int() as key,
                "is_down": bool() as is_down,
            }:
                return cls(X11Key(key), is_down)
            case _:
                raise ValueError(f"Invalid KeyEvent dict: {event_dict}")

    def to_dict(self) -> dict[str, int]:
        return {
            "key": self.key.value,
            "is_down": self.is_down,
        }


@dataclass(frozen=True)
class PointerEvent:
    """
    https://datatracker.ietf.org/doc/html/rfc6143#section-7.5.5

    A PointerEvent message indicates either pointer movement or a pointer
    button press or release.  The pointer is now at (x-position,
    y-position), and the current state of buttons 1 to 8 are represented
    by bits 0 to 7 of button-mask, respectively; 0 means up, 1 means down
    (pressed).

    On a conventional mouse, buttons 1, 2, and 3 correspond to the left,
    middle, and right buttons on the mouse.  On a wheel mouse, each step
    of the wheel upwards is represented by a press and release of button
    4, and each step downwards is represented by a press and release of
    button 5.

               +--------------+--------------+--------------+
               | No. of bytes | Type [Value] | Description  |
               +--------------+--------------+--------------+
               | 1            | U8 [5]       | message-type |
               | 1            | U8           | button-mask  |
               | 2            | U16          | x-position   |
               | 2            | U16          | y-position   |
               +--------------+--------------+--------------+
    """

    buttons: MouseButtons  # u8
    x: int  # u16
    y: int  # u16

    _STRUCT_NO_TAG: ClassVar[Struct] = Struct("!BHH")
    _STRUCT_WITH_TAG: ClassVar[Struct] = Struct("!BBHH")

    @classmethod
    def from_bytes(cls, message: IO[bytes]) -> Self:
        buttons_int, x, y = _unpack_stream(cls._STRUCT_NO_TAG, message)
        return cls(buttons=MouseButtons(buttons_int), x=x, y=y)

    def to_bytes(self) -> bytes:
        return self._STRUCT_WITH_TAG.pack(
            ClientMessageKind.POINTER_EVENT.value,
            self.buttons.value,
            self.x,
            self.y,
        )

    @classmethod
    def from_dict(cls, event_dict: dict[str, int]) -> Self:
        match event_dict:
            case {
                "buttons": int() as buttons,
                "x": int() as x,
                "y": int() as y,
            } if 0 <= x < 65536 and 0 <= y < 65536 and 0 <= buttons < 256:
                return cls(MouseButtons(buttons), x, y)
            case _:
                raise ValueError(f"Invalid PointerEvent dict: {event_dict}")

    def to_dict(self) -> dict[str, int]:
        return {
            "buttons": self.buttons.value,
            "x": self.x,
            "y": self.y,
        }


class MouseButtons(Flag):
    """
    Mouse buttons mask with their corresponding bitmask values used in the VNC protocol.
    """

    LEFT = 0b0000_0001
    MIDDLE = 0b0000_0010
    RIGHT = 0b0000_0100
    SCROLL_UP = 0b0000_1000
    SCROLL_DOWN = 0b0001_0000
    SCROLL_LEFT = 0b0010_0000
    SCROLL_RIGHT = 0b0100_0000
    BUTTON_8 = 0b1000_0000

    # Backwards-compatibility aliases (RFB refers to these as buttons 6/7)
    BUTTON_6 = SCROLL_LEFT
    BUTTON_7 = SCROLL_RIGHT

    @classmethod
    def build_mask(cls, buttons: Iterable[Self]) -> Self:
        button_mask = cls(0)
        for button in buttons or ():
            button_mask |= button
        return button_mask

    def down(self, buttons: Self) -> Self:
        return self | buttons

    def up(self, buttons: Self) -> Self:
        return self & (~buttons)


@dataclass(frozen=True)
class ClientCutText:
    """
    https://datatracker.ietf.org/doc/html/rfc6143#section-7.5.6

    RFB provides limited support for synchronizing the "cut buffer" of
    selected text between client and server.  This message tells the
    server that the client has new ISO 8859-1 (Latin-1) text in its cut
    buffer.  Ends of lines are represented by the newline character (hex
    0a) alone.  No carriage-return (hex 0d) is used.  There is no way to
    transfer text outside the Latin-1 character set.

               +--------------+--------------+--------------+
               | No. of bytes | Type [Value] | Description  |
               +--------------+--------------+--------------+
               | 1            | U8 [6]       | message-type |
               | 3            |              | padding      |
               | 4            | U32          | length       |
               | length       | U8 array     | text         |
               +--------------+--------------+--------------+
    """

    text: bytes

    @classmethod
    def from_bytes(cls, message: IO[bytes]) -> Self:
        (length,) = _unpack_stream(Struct("!xxxl"), message)
        if length < 0:
            length = -length
        return cls(_read_exactly(message, length))


class QemuClientMessageKind(Enum):
    EXTENDED_KEY_EVENT = 0
    AUDIO = 1

    # +--------------+--------------+--------------+
    # | No. of bytes | Type [Value] | Description  |
    # +--------------+--------------+--------------+
    # | 1            | U8 [4]       | message-type |
    # | 1            | U8           | down-flag    |
    # | 2            |              | padding      |
    # | 4            | U32          | key          |
    # +--------------+--------------+--------------+


@dataclass(frozen=True)
class QemuExtendedKeyEvent:
    """
    https://github.com/rfbproto/rfbproto/blob/master/rfbproto.rst#qemu-extended-key-event-message

    QEMU Extended Key Event Message
    ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

    This submessage allows the client to send an extended key event
    containing a keycode, in addition to a keysym. The advantage of
    providing the keycode is that it enables the server to interpret
    the key event independently of the clients' locale specific
    keymap. This can be important for virtual desktops whose key
    input device requires scancodes, for example, virtual machines
    emulating a PS/2 keycode. Prior to this extension, RFB servers
    for such virtualization software would have to be configured
    with a keymap matching the client. With this extension it is
    sufficient for the guest operating system to be configured with
    the matching keymap. The VNC server is keymap independent.

    The full message is:

    =============== ==================== ========== =======================
    No. of bytes    Type                 [Value]    Description
    =============== ==================== ========== =======================
    1               ``U8``               255        *message-type*
    1               ``U8``               0          *submessage-type*
    2               ``U16``                         *down-flag*
    4               ``U32``                         *keysym*
    4               ``U32``                         *keycode*
    =============== ==================== ========== =======================

    The *keysym* and *down-flag* fields also take the same values as
    described for the `KeyEvent`_ message. Auto repeating behaviour
    of keys is also as described for the `KeyEvent`_ message.

    The *keycode* is the XT keycode that produced the *keysym*. An
    XT keycode is an XT make scancode sequence encoded to fit in
    a single ``U32`` quantity. Single byte XT scancodes with a byte
    value less than 0x7f are encoded as is. 2-byte XT scancodes
    whose first byte is 0xe0 and second byte is less than 0x7f are
    encoded with the high bit of the first byte set. Some example
    mappings are

    ============= ================== ============ ==========
    XT scancode   X11 keysym         RFB keycode  down-flag
    ============= ================== ============ ==========
    0x1e          XK_A (0x41)        0x1e         1
    0x9e          XK_A (0x41)        0x1e         0
    0xe0 0x4d     XK_Right (0xff53)  0xcd         1
    0xe0 0xcd     XK_Right (0xff53)  0xcd         0
    ============= ================== ============ ==========

    The multi-byte scancode sequence for the Print/SysRq key SHOULD be sent
    as 0x54, regardless of what modifier keys are currently pressed. For
    backwards compatibility servers SHOULD also accept 0xb7 as a synonym
    for 0x54.

    The multi-byte scancode sequence for the Pause/Break key MUST be sent
    as 0xc6, regardless of what modifier keys are currently pressed.

    An unknown keysym should have the value 0. The client must not send a
    QEMU Extended Key Event Message if the keycode isn't known. Instead a
    standard `KeyEvent`_ message should be used.
    """

    keysym: X11Key  # u32
    keycode: int  # u32
    is_down: bool  # u16

    _STRUCT_NO_TAG: ClassVar[Struct] = Struct("!HII")
    _STRUCT_WITH_TAG: ClassVar[Struct] = Struct("!BBHII")

    @classmethod
    def from_bytes(cls, message: IO[bytes]) -> Self:
        is_down, keysym, keycode = _unpack_stream(cls._STRUCT_NO_TAG, message)
        return cls(
            keysym=X11Key(keysym),
            keycode=keycode,
            is_down=is_down != 0,
        )

    def to_bytes(self) -> bytes:
        return self._STRUCT_WITH_TAG.pack(
            ClientMessageKind.QEMU,
            QemuClientMessageKind.EXTENDED_KEY_EVENT,
            self.is_down,
            self.keysym.value,
            self.keycode,
        )

    @classmethod
    def from_dict(cls, event_dict: Mapping[str, int]) -> Self:
        match event_dict:
            case {
                "keysym": int() as keysym,
                "keycode": int() as keycode,
                "is_down": bool() as is_down,
            }:
                return cls(keysym=X11Key(keysym), keycode=keycode, is_down=is_down)
            case _:
                raise ValueError(f"Invalid KeyEvent dict: {event_dict}")

    def to_dict(self) -> dict[str, int]:
        return {
            "keysym": self.keysym.value,
            "keycode": self.keycode,
            "is_down": self.is_down,
        }


ClientMessage = (
    SetPixelFormat
    | SetEncodings
    | FramebufferUpdateRequest
    | KeyEvent
    | PointerEvent
    | ClientCutText
    | QemuExtendedKeyEvent
)


def parse_client_message(message: IO[bytes]) -> ClientMessage:
    kind = ClientMessageKind(_read_exactly(message, 1)[0])

    match kind:
        case ClientMessageKind.SET_PIXEL_FORMAT:
            return SetPixelFormat.from_bytes(message)
        case ClientMessageKind.SET_ENCODINGS:
            return SetEncodings.from_bytes(message)
        case ClientMessageKind.FRAMEBUFFER_UPDATE_REQUEST:
            return FramebufferUpdateRequest.read_from(message)
        case ClientMessageKind.KEY_EVENT:
            return KeyEvent.from_bytes(message)
        case ClientMessageKind.POINTER_EVENT:
            return PointerEvent.from_bytes(message)
        case ClientMessageKind.CLIENT_CUT_TEXT:
            return ClientCutText.from_bytes(message)
        case ClientMessageKind.QEMU:
            return parse_qemu_client_message(message)
        case _:
            raise RuntimeError(f"Unexpected client message, kind: {kind} message: {message}")


def parse_qemu_client_message(message: IO[bytes]) -> QemuExtendedKeyEvent:
    # There are more QEMU client messages which we don't yet support. `QemuClientMessage` should
    # become a union of QEMU message once we support more QEMU messages.
    #
    # See https://github.com/rfbproto/rfbproto/blob/master/rfbproto.rst#qemu-client-message
    qemu_kind = QemuClientMessageKind(_read_exactly(message, 1)[0])

    match qemu_kind:
        case QemuClientMessageKind.EXTENDED_KEY_EVENT:
            return QemuExtendedKeyEvent.from_bytes(message)
        case _:
            raise RuntimeError(
                f"Unexpected QEMU client message, kind: {qemu_kind} message: {message}"
            )


#   ____                             __  __
#  / ___|  ___ _ ____   _____ _ __  |  \/  | ___  ___ ___  __ _  __ _  ___  ___
#  \___ \ / _ \ '__\ \ / / _ \ '__| | |\/| |/ _ \/ __/ __|/ _` |/ _` |/ _ \/ __|
#   ___) |  __/ |   \ V /  __/ |    | |  | |  __/\__ \__ \ (_| | (_| |  __/\__ \
#  |____/ \___|_|    \_/ \___|_|    |_|  |_|\___||___/___/\__,_|\__, |\___||___/
#                                                               |___/


class ServerMessageKind(Enum):
    """
    https://datatracker.ietf.org/doc/html/rfc6143#section-7.6

    The server-to-client message types defined in this document are:

                      +--------+--------------------+
                      | Number | Name               |
                      +--------+--------------------+
                      | 0      | FramebufferUpdate  |
                      | 1      | SetColorMapEntries |
                      | 2      | Bell               |
                      | 3      | ServerCutText      |
                      +--------+--------------------+

    Other private message types exist but are not publicly documented.
    Before sending a message other than those described in this document
    a server must have determined that the client supports the relevant
    extension by receiving some extension-specific confirmation from the
    client -- usually a request for a given pseudo-encoding.
    """

    FRAMEBUFFER_UPDATE = 0
    SET_COLOR_MAP_ENTRIES = 1
    BELL = 2
    SERVER_CUT_TEXT = 3


@dataclass(frozen=True)
class TightRectFill:
    """
    Tight fill compression

    If the compression type is FillCompression, then the only pixel value follows, in TPIXEL
    format. This value applies to all pixels of the rectangle.

    See https://github.com/rfbproto/rfbproto/blob/master/rfbproto.rst#767tight-encoding
    """

    color: tuple[int, int, int]


@dataclass(frozen=True)
class TightRectJpeg:
    """
    Tight JPEG compression

    See https://github.com/rfbproto/rfbproto/blob/master/rfbproto.rst#767tight-encoding
    """

    data: bytes = field(repr=False)

    def __post_init__(self):
        MAGIC_NUMBER = b"\xff\xd8\xff\xe0\x00\x10JFIF"
        assert self.data[: len(MAGIC_NUMBER)] == MAGIC_NUMBER, self.data[:1000]


@dataclass(frozen=True)
class TightRectCopyFilter:
    """
    Tight copy filter

    When the CopyFilter is active, raw pixel values in TPIXEL format will be compressed.

    See https://github.com/rfbproto/rfbproto/blob/master/rfbproto.rst#767tight-encoding
    """

    stream_id: int
    data: bytes


@dataclass(frozen=True)
class TightRectPaletteFilter:
    """
    Tight palette filter

    The PaletteFilter converts true-color pixel data to indexed colors and a palette which can
    consist of 2..256 colors. If the number of colors is 2, then each pixel is encoded in 1 bit,
    otherwise 8 bits are used to encode one pixel. 1-bit encoding is performed such way that the
    most significant bits correspond to the leftmost pixels, and each row of pixels is aligned to
    the byte boundary. When the PaletteFilter is used, the palette is sent before the pixel
    data. The palette begins with an unsigned byte which value is the number of colors in the
    palette minus 1 (i.e. 1 means 2 colors, 255 means 256 colors in the palette). Then follows the
    palette itself which consist of pixel values in TPIXEL format.

    See https://github.com/rfbproto/rfbproto/blob/master/rfbproto.rst#767tight-encoding
    """

    stream_id: int
    palette: tuple[tuple[int, int, int], ...]
    bits_per_pixel: int
    data: bytes
    compressed: bool


TightRectContent = TightRectFill | TightRectJpeg | TightRectCopyFilter | TightRectPaletteFilter


@dataclass(frozen=True)
class TightRect:
    """
    Tight encoding provides efficient compression for pixel data.

    See https://github.com/rfbproto/rfbproto/blob/master/rfbproto.rst#767tight-encoding
    """

    patch: Rectangle
    content: TightRectContent
    reset_streams: tuple[int, ...]

    NUM_ZLIB_STREAMS: ClassVar[int] = 4

    _TIGHT_PIXEL_STRUCT: ClassVar[Struct] = Struct("BBB")
    _BASIC_COMPRESSION_FLAG: ClassVar[int] = 0b1000
    _FILL_COMPRESSION_PATTERN: ClassVar[int] = 0b1000
    _JPEG_COMPRESSION_PATTERN: ClassVar[int] = 0b1001

    @classmethod
    def from_bytes(cls, message: IO[bytes], patch: Rectangle) -> Self:
        compression_control = _read_exactly(message, 1)[0]
        reset_streams = tuple(
            (compression_control >> stream_id) & 1
            for stream_id in range(cls.NUM_ZLIB_STREAMS)  # 0, 1, 2, 3
        )

        compression_control = compression_control >> cls.NUM_ZLIB_STREAMS  # >> 4

        if compression_control == cls._FILL_COMPRESSION_PATTERN:  # == 0b1000
            content = TightRectFill(_unpack_stream(cls._TIGHT_PIXEL_STRUCT, message))
        elif compression_control == cls._JPEG_COMPRESSION_PATTERN:  # == 0b1001
            content = TightRectJpeg(_read_exactly(message, _decode_varint(message)))
        elif (compression_control & cls._BASIC_COMPRESSION_FLAG) == 0:  # & 0b1000
            stream_id = compression_control & 0b11

            pixel_filter = 0
            if compression_control & 0b100:
                pixel_filter = _read_exactly(message, 1)[0]

            match pixel_filter:
                case 0:  # COPY_FILTER
                    length = _decode_varint(message)
                    pixel_data = _read_exactly(message, length)
                    content = TightRectCopyFilter(stream_id=stream_id, data=pixel_data)
                case 1:  # PALETTE_FILTER
                    num_colors = _read_exactly(message, 1)[0] + 1
                    palette = tuple(
                        _unpack_stream(cls._TIGHT_PIXEL_STRUCT, message) for _ in range(num_colors)
                    )
                    bits_per_pixel = 1 if num_colors <= 2 else 8
                    row_size = (patch.width * bits_per_pixel + 7) // 8
                    uncompressed_size = row_size * patch.height
                    if uncompressed_size < 12:
                        compressed = False
                        pixel_data = _read_exactly(message, uncompressed_size)
                    else:
                        compressed = True
                        length = _decode_varint(message)
                        pixel_data = _read_exactly(message, length)

                    content = TightRectPaletteFilter(
                        stream_id=stream_id,
                        palette=palette,
                        bits_per_pixel=bits_per_pixel,
                        data=pixel_data,
                        compressed=compressed,
                    )
                case 2:  # GRADIENT_FILTER
                    raise NotImplementedError("Tight GRADIENT_FILTER not supported")
                case _:
                    raise ValueError(f"Illegal tight filter encountered: {pixel_filter}")
        else:
            raise ValueError(f"Only JPEG or FILL compression is supported for TightRect {message=}")

        return cls(patch, content, reset_streams)


def _decode_varint(stream: IO[bytes]) -> int:
    """
    Read a varint up to 3 bytes wide from a `stream`

    Compactly represented in one, two or three bytes, according to the following scheme:

        Value                       Description
        0xxxxxxx                    for values 0..127
        1xxxxxxx 0yyyyyyy           for values 128..16383
        1xxxxxxx 1yyyyyyy zzzzzzzz  for values 16384..4194303

    Here each character denotes one bit, xxxxxxx are the least significant 7 bits of the
    value (bits 0-6), yyyyyyy are bits 7-13, and zzzzzzzz are the most significant 8 bits
    (bits 14-21). For example, decimal value 10000 should be represented as two bytes:
    binary 10010000 01001110, or hexadecimal 90 4E.
    """

    byte: int = _read_exactly(stream, 1)[0]
    value: int = byte & 0x7F

    if byte & 0x80:
        byte = _read_exactly(stream, 1)[0]
        value |= (byte & 0x7F) << 7

        if byte & 0x80:
            byte = _read_exactly(stream, 1)[0]
            value |= byte << 14

    return value


@dataclass(frozen=True)
class Rectangle:
    x: int  # u16
    y: int  # u16
    width: int  # u16
    height: int  # u16
    encoding: Encoding


@dataclass(frozen=True)
class RawRect:
    """
    https://datatracker.ietf.org/doc/html/rfc6143#section-7.7.1

    The simplest encoding type is raw pixel data.  In this case, the data
    consists of width*height pixel values (where width and height are the
    width and height of the rectangle).  The values simply represent each
    pixel in left-to-right scan line order.  All RFB clients must be able
    to handle pixel data in this raw encoding, and RFB servers should
    only produce raw encoding unless the client specifically asks for
    some other encoding type.

         +----------------------------+--------------+-------------+
         | No. of bytes               | Type [Value] | Description |
         +----------------------------+--------------+-------------+
         | width*height*bytesPerPixel | PIXEL array  | pixels      |
         +----------------------------+--------------+-------------+
    """

    patch: Rectangle
    data: bytes  # raw encoded, width * height * bytes_per_pixel

    @classmethod
    def from_bytes(cls, message: IO[bytes], patch: Rectangle, bytes_per_pixel: int) -> Self:
        return cls(
            patch=patch,
            data=_read_exactly(message, patch.width * patch.height * bytes_per_pixel),
        )


@dataclass(frozen=True)
class CopyRect:
    """
    https://datatracker.ietf.org/doc/html/rfc6143#section-7.7.2

    The CopyRect (copy rectangle) encoding is a very simple and efficient
    encoding that can be used when the client already has the same pixel
    data elsewhere in its framebuffer.  The encoding on the wire simply
    consists of an X,Y coordinate.  This gives a position in the
    framebuffer from which the client can copy the rectangle of pixel
    data.  This can be used in a variety of situations, the most common
    of which are when the user moves a window across the screen, and when
    the contents of a window are scrolled.

              +--------------+--------------+----------------+
              | No. of bytes | Type [Value] | Description    |
              +--------------+--------------+----------------+
              | 2            | U16          | src-x-position |
              | 2            | U16          | src-y-position |
              +--------------+--------------+----------------+

    For maximum compatibility, the source rectangle of a CopyRect should
    not include pixels updated by previous entries in the same
    FramebufferUpdate message.
    """

    patch: Rectangle
    source_x: int  # u16
    source_y: int  # u16

    _STRUCT: ClassVar[Struct] = Struct("!HH")

    @classmethod
    def from_bytes(cls, message: IO[bytes], patch: Rectangle) -> Self:
        source_x, source_y = _unpack_stream(cls._STRUCT, message)
        return cls(patch=patch, source_x=source_x, source_y=source_y)


@dataclass(frozen=True)
class PseudoCursorRect:
    """
    https://datatracker.ietf.org/doc/html/rfc6143#section-7.8.1

    A client that requests the Cursor pseudo-encoding is declaring that
    it is capable of drawing a pointer cursor locally.  This can
    significantly improve perceived performance over slow links.  The
    server sets the cursor shape by sending a rectangle with the Cursor
    pseudo-encoding as part of an update.  The rectangle's x-position and
    y-position indicate the hotspot of the cursor, and width and height
    indicate the width and height of the cursor in pixels.  The data
    consists of width*height raw pixel values followed by a shape
    bitmask, with one bit corresponding to each pixel in the cursor
    rectangle.  The bitmask consists of left-to-right, top-to-bottom scan
    lines, where each scan line is padded to a whole number of bytes, the
    number being div(width+7,8).  Within each byte, the most significant
    bit represents the leftmost pixel; a bit set to 1 means the
    corresponding pixel in the cursor is valid.

        +----------------------------+--------------+---------------+
        | No. of bytes               | Type [Value] | Description   |
        +----------------------------+--------------+---------------+
        | width*height*bytesPerPixel | PIXEL array  | cursor-pixels |
        | div(width+7,8)*height      | U8 array     | bitmask       |
        +----------------------------+--------------+---------------+
    """

    patch: Rectangle
    image: bytes  # raw encoded, width * height * bytes_per_pixel
    mask: bytes  # 1 bit / pixel, padded, ((width + 7) // 8) * height

    @classmethod
    def from_bytes(cls, message: IO[bytes], patch: Rectangle, bytes_per_pixel: int) -> Self:
        image_num_bytes = patch.width * patch.height * bytes_per_pixel
        image = _read_exactly(message, image_num_bytes)

        mask_num_bytes = ((patch.width + 7) // 8) * patch.height
        mask = _read_exactly(message, mask_num_bytes)

        return cls(patch=patch, image=image, mask=mask)


@dataclass(frozen=True)
class PseudoLastRect:
    patch: Rectangle  # parsed from the stream, but it has no meaning for LastRect


@dataclass(frozen=True)
class PseudoExtendedDesktopScreen:
    screen_id: int  # u32
    x: int  # u16
    y: int  # u16
    width: int  # u16
    height: int  # u16
    flags: int  # u32


@dataclass(frozen=True)
class PseudoExtendedDesktopSizeRect:
    num_screens: int
    screens: tuple[PseudoExtendedDesktopScreen, ...]

    @classmethod
    def from_bytes(cls, message: IO[bytes]) -> Self:
        (num_screens,) = _unpack_stream(Struct("!Bxxx"), message)
        screens: list[PseudoExtendedDesktopScreen] = []
        for _ in range(num_screens):
            screen_id, x, y, width, height, flags = _unpack_stream(Struct("!LHHHHL"), message)
            screens.append(
                PseudoExtendedDesktopScreen(
                    screen_id=screen_id,
                    x=x,
                    y=y,
                    width=width,
                    height=height,
                    flags=flags,
                )
            )

        return cls(num_screens, tuple(screens))


@dataclass(frozen=True)
class PseudoQemuExtendedKeyEventRect:
    """
    https://github.com/rfbproto/rfbproto/blob/master/rfbproto.rst#qemu-extended-key-event-pseudo-encoding

    A client that supports this encoding is indicating that it can toggle the state of lock keys on
    the local keyboard. The server will send a pseudo-rectangle with the following contents when it
    wishes to update the client's state:
    """


class QemuLedState(Flag):
    """
    Mask for the state of lock keys on the local keyboard.
    """

    SCROLL_LOCK = 0b0000_0001
    NUM_LOCK = 0b0000_0010
    CAPS_LOCK = 0b0000_0100


@dataclass(frozen=True)
class PseudoQemuLedStateRect:
    """
    https://github.com/rfbproto/rfbproto/blob/master/rfbproto.rst#qemu-led-state-pseudo-encoding

    A client that supports this encoding is indicating that it can toggle the state of lock keys on
    the local keyboard. The server will send a pseudo-rectangle with the following contents when it
    wishes to update the client's state:

    =============== =================== ===================================
    No. of bytes    Type                Description
    =============== =================== ===================================
    1               ``U8``              *state*
    =============== =================== ===================================

    The bits of *state* are defined as:

    =============== =======================================================
    Bit             Description
    =============== =======================================================
    0               Scroll Lock
    1               Num Lock
    2               Caps Lock
    =============== =======================================================

    The remaining bits are reserved and must be ignored.

    An update must be sent whenever the server state changes, but may also be sent at other times
    to compensate for variance in behaviour between the server and client keyboard handling.
    """

    state: QemuLedState

    _STRUCT: ClassVar[Struct] = Struct("!B")

    @classmethod
    def from_bytes(cls, message: IO[bytes]) -> Self:
        (flag,) = _unpack_stream(cls._STRUCT, message)
        return cls(state=QemuLedState((flag)))


FramebufferUpdateRect = (
    RawRect
    | CopyRect
    | TightRect
    | PseudoCursorRect
    | PseudoExtendedDesktopSizeRect
    | PseudoLastRect
    | PseudoQemuExtendedKeyEventRect
    | PseudoQemuLedStateRect
)


@dataclass(frozen=True)
class FramebufferUpdate:
    """
    https://datatracker.ietf.org/doc/html/rfc6143#section-7.6.1

    A framebuffer update consists of a sequence of rectangles of pixel
    data that the client should put into its framebuffer.  It is sent in
    response to a FramebufferUpdateRequest from the client.  Note that
    there may be an indefinite period between the
    FramebufferUpdateRequest and the FramebufferUpdate.

           +--------------+--------------+----------------------+
           | No. of bytes | Type [Value] | Description          |
           +--------------+--------------+----------------------+
           | 1            | U8 [0]       | message-type         |
           | 1            |              | padding              |
           | 2            | U16          | number-of-rectangles |
           +--------------+--------------+----------------------+

    This header is followed by number-of-rectangles rectangles of pixel
    data.  Each rectangle starts with a rectangle header:

               +--------------+--------------+---------------+
               | No. of bytes | Type [Value] | Description   |
               +--------------+--------------+---------------+
               | 2            | U16          | x-position    |
               | 2            | U16          | y-position    |
               | 2            | U16          | width         |
               | 2            | U16          | height        |
               | 4            | S32          | encoding-type |
               +--------------+--------------+---------------+

    The rectangle header is followed by the pixel data in the specified
    encoding.  See Section 7.7 for the format of the data for each
    encoding and Section 7.8 for the meaning of pseudo-encodings.
    """

    num_rectangles: int  # u16
    rectangles: tuple[FramebufferUpdateRect, ...]

    _HEADER_STRUCT: ClassVar[Struct] = Struct("!xH")

    @classmethod
    def from_bytes(cls, message: IO[bytes], bytes_per_pixel: int) -> Self:
        """
        Parses the message from raw bytes. The leading message-type byte should not be included.
        """
        rectangles: list[FramebufferUpdateRect] = []
        (num_rectangles,) = _unpack_stream(cls._HEADER_STRUCT, message)

        for _ in range(num_rectangles):
            rectangle = FramebufferUpdate.parse_rect(message, bytes_per_pixel)
            rectangles.append(rectangle)
            if isinstance(rectangle, PseudoLastRect):
                break

        return cls(num_rectangles, tuple(rectangles))

    @staticmethod
    def parse_rect(message: IO[bytes], bytes_per_pixel: int) -> FramebufferUpdateRect:
        """
        Parses a rectangle update from raw bytes. Used as part of a `FramebufferUpdate` message.
        """
        (x, y, width, height, encoding_int) = _unpack_stream(Struct("!HHHHi"), message)
        rect = Rectangle(x, y, width, height, Encoding(encoding_int))

        match rect.encoding:
            case Encoding.RAW:
                return RawRect.from_bytes(message, rect, bytes_per_pixel)
            case Encoding.COPY_RECTANGLE:
                return CopyRect.from_bytes(message, rect)
            case Encoding.TIGHT:
                return TightRect.from_bytes(message, rect)
            case Encoding.PSEUDO_LAST_RECT:
                return PseudoLastRect(rect)
            case Encoding.PSEUDO_CURSOR:
                return PseudoCursorRect.from_bytes(message, rect, bytes_per_pixel)
            case Encoding.PSEUDO_EXTENDED_DESKTOP_SIZE:
                return PseudoExtendedDesktopSizeRect.from_bytes(message)
            case Encoding.PSEUDO_QEMU_EXTENDED_KEY_EVENT:
                return PseudoQemuExtendedKeyEventRect()
            case Encoding.PSEUDO_QEMU_LED_STATE:
                return PseudoQemuLedStateRect.from_bytes(message)
            case _:
                raise NotImplementedError(f"Unsupported rect update with encoding {rect.encoding}")


@dataclass(frozen=True)
class SetColorMapEntries:
    """
    https://datatracker.ietf.org/doc/html/rfc6143#section-7.6.2

    When the pixel format uses a "color map", this message tells the
    client that the specified pixel values should be mapped to the given
    RGB values.  Note that this message may only update part of the color
    map.  This message should not be sent by the server until after the
    client has sent at least one FramebufferUpdateRequest, and only when
    the agreed pixel format uses a color map.

    Color map values are always 16 bits, with the range of values running
    from 0 to 65535, regardless of the display hardware in use.  The
    color map value for white, for example, is 65535,65535,65535.

    The message starts with a header describing the range of colormap
    entries to be updated.

             +--------------+--------------+------------------+
             | No. of bytes | Type [Value] | Description      |
             +--------------+--------------+------------------+
             | 1            | U8 [1]       | message-type     |
             | 1            |              | padding          |
             | 2            | U16          | first-color      |
             | 2            | U16          | number-of-colors |
             +--------------+--------------+------------------+

    This header is followed by number-of-colors RGB values, each of which
    is in this format:

                +--------------+--------------+-------------+
                | No. of bytes | Type [Value] | Description |
                +--------------+--------------+-------------+
                | 2            | U16          | red         |
                | 2            | U16          | green       |
                | 2            | U16          | blue        |
                +--------------+--------------+-------------+
    """

    first_color: int  # u16
    number_of_colors: int  # u16
    colors: tuple[tuple[int, int, int], ...]  # (RGB, ...)

    _STRUCT: ClassVar[Struct] = Struct("xHH")
    _COLOR_STRUCT: ClassVar[Struct] = Struct("HHH")

    @classmethod
    def from_bytes(cls, message: IO[bytes]) -> Self:
        """
        Parses the message from raw bytes. The leading message-type byte should not be included.
        """
        first_color, number_of_colors = _unpack_stream(cls._STRUCT, message)

        colors: list[tuple[int, int, int]] = []
        for _ in range(number_of_colors):
            colors.append(_unpack_stream(cls._COLOR_STRUCT, message))

        return cls(
            first_color=first_color,
            number_of_colors=number_of_colors,
            colors=tuple(colors),
        )


@dataclass(frozen=True)
class Bell:
    """
    https://datatracker.ietf.org/doc/html/rfc6143#section-7.6.3

    A Bell message makes an audible signal on the client if it provides
    one.

              +--------------+--------------+--------------+
              | No. of bytes | Type [Value] | Description  |
              +--------------+--------------+--------------+
              | 1            | U8 [2]       | message-type |
              +--------------+--------------+--------------+
    """


@dataclass(frozen=True)
class ServerCutText:
    """
    https://datatracker.ietf.org/doc/html/rfc6143#section-7.6.4

    The server has new ISO 8859-1 (Latin-1) text in its cut buffer.  Ends
    of lines are represented by the newline character (hex 0a) alone.  No
    carriage-return (hex 0d) is used.  There is no way to transfer text
    outside the Latin-1 character set.

               +--------------+--------------+--------------+
               | No. of bytes | Type [Value] | Description  |
               +--------------+--------------+--------------+
               | 1            | U8 [3]       | message-type |
               | 3            |              | padding      |
               | 4            | U32          | length       |
               | length       | U8 array     | text         |
               +--------------+--------------+--------------+
    """

    text: bytes

    @classmethod
    def from_bytes(cls, message: IO[bytes]) -> Self:
        """
        Parses the message from raw bytes. The leading message-type byte should not be included.
        """
        (length,) = _unpack_stream(Struct("!xxxl"), message)

        if length < 0:
            length = -length
        return cls(_read_exactly(message, length))


@dataclass(frozen=True)
class UnknownServerMessage:
    """Vendor/private server-to-client message we don't explicitly support.

    We conservatively consume only the 1-byte kind header and ignore payload (if any).
    This keeps the parser resilient during export; such messages are rare and typically
    do not affect framebuffer state.
    """

    kind: int


ServerMessage = FramebufferUpdate | SetColorMapEntries | Bell | ServerCutText | UnknownServerMessage


def parse_server_message(message: IO[bytes], bytes_per_pixel: int | None) -> ServerMessage:
    kind_byte = _read_exactly(message, 1)[0]
    try:
        kind = ServerMessageKind(kind_byte)
    except ValueError:
        # Unknown vendor/private message; return a placeholder so callers can skip
        return UnknownServerMessage(kind=kind_byte)

    match kind:
        case ServerMessageKind.FRAMEBUFFER_UPDATE:
            assert bytes_per_pixel is not None
            return FramebufferUpdate.from_bytes(message, bytes_per_pixel)
        case ServerMessageKind.SET_COLOR_MAP_ENTRIES:
            return SetColorMapEntries.from_bytes(message)
        case ServerMessageKind.BELL:
            return Bell()
        case ServerMessageKind.SERVER_CUT_TEXT:
            return ServerCutText.from_bytes(message)
        case _:
            # Should be unreachable due to try/except above, but keep safe fallback
            return UnknownServerMessage(kind=kind_byte)


#   _   _                 _     _           _          __  __
#  | | | | __ _ _ __   __| |___| |__   __ _| | _____  |  \/  | ___  ___ ___  __ _  __ _  ___  ___
#  | |_| |/ _` | '_ \ / _` / __| '_ \ / _` | |/ / _ \ | |\/| |/ _ \/ __/ __|/ _` |/ _` |/ _ \/ __|
#  |  _  | (_| | | | | (_| \__ \ | | | (_| |   <  __/ | |  | |  __/\__ \__ \ (_| | (_| |  __/\__ \
#  |_| |_|\__,_|_| |_|\__,_|___/_| |_|\__,_|_|\_\___| |_|  |_|\___||___/___/\__,_|\__, |\___||___/
#                                                                                 |___/


@dataclass(frozen=True)
class ProtocolVersion:
    """
    https://datatracker.ietf.org/doc/html/rfc6143#section-7.1.1

    Handshaking begins by the server sending the client a ProtocolVersion
    message.  This lets the client know which is the highest RFB protocol
    version number supported by the server.  The client then replies with
    a similar message giving the version number of the protocol that
    should actually be used (which may be different to that quoted by the
    server).  A client should never request a protocol version higher
    than that offered by the server.  It is intended that both clients
    and servers may provide some level of backwards compatibility by this
    mechanism.

    The only published protocol versions at this time are 3.3, 3.7, and
    3.8.  Other version numbers are reported by some servers and clients,
    but should be interpreted as 3.3 since they do not implement the
    different handshake in 3.7 or 3.8.  Addition of a new encoding or
    pseudo-encoding type does not require a change in protocol version,
    since a server can simply ignore encodings it does not understand.

    The ProtocolVersion message consists of 12 bytes interpreted as a
    string of ASCII characters in the format "RFB xxx.yyy\\n" where xxx
    and yyy are the major and minor version numbers, left-padded with
    zeros:

       RFB 003.008\\n

    """

    NUM_BYTES: ClassVar[int] = 12

    version: bytes

    def __post_init__(self) -> None:
        if len(self.version) != ProtocolVersion.NUM_BYTES or self.version[:4] != b"RFB ":
            raise ValueError(f"Invalid protocol version: {self.version}")

    @classmethod
    def from_bytes(cls, stream: IO[bytes]) -> Self:
        return cls(_read_exactly(stream, cls.NUM_BYTES))

    def to_bytes(self) -> bytes:
        return self.version


@dataclass(frozen=True)
class ServerSecurity:
    """
    https://datatracker.ietf.org/doc/html/rfc6143#section-7.1.2

    Once the protocol version has been decided, the server and client
    must agree on the type of security to be used on the connection.  The
    server lists the security types that it supports:

    +--------------------------+-------------+--------------------------+
    | No. of bytes             | Type        | Description              |
    +--------------------------+-------------+--------------------------+
    | 1                        | U8          | number-of-security-types |
    | number-of-security-types | U8 array    | security-types           |
    +--------------------------+-------------+--------------------------+
    """

    supported: tuple[SecurityType, ...]

    @classmethod
    def from_bytes(cls, stream: IO[bytes]) -> Self:
        num_security_types = _read_exactly(stream, 1)[0]
        return cls(supported=tuple(map(SecurityType, _read_exactly(stream, num_security_types))))


@dataclass(frozen=True)
class ServerSecurityResult:
    """
    https://datatracker.ietf.org/doc/html/rfc6143#section-7.1.3

    The server sends a word to inform the client whether the security
    handshaking was successful.

               +--------------+--------------+-------------+
               | No. of bytes | Type [Value] | Description |
               +--------------+--------------+-------------+
               | 4            | U32          | status:     |
               |              | 0            | OK          |
               |              | 1            | failed      |
               +--------------+--------------+-------------+

    If successful, the protocol passes to the initialization phase.

    If unsuccessful, the server sends a string describing the reason for
    the failure, and then closes the connection:

             +---------------+--------------+---------------+
             | No. of bytes  | Type [Value] | Description   |
             +---------------+--------------+---------------+
             | 4             | U32          | reason-length |
             | reason-length | U8 array     | reason-string |
             +---------------+--------------+---------------+
    """

    success: bool
    reason: str

    _STATUS_STRUCT: ClassVar[Struct] = Struct("!l")
    _REASON_LEN_STRUCT: ClassVar[Struct] = Struct("!l")

    @classmethod
    def from_bytes(cls, stream: IO[bytes]) -> Self:
        (status,) = _unpack_stream(cls._STATUS_STRUCT, stream)
        success = status == 0
        if success:
            reason = ""
        else:
            (reason_len,) = _unpack_stream(cls._REASON_LEN_STRUCT, stream)
            reason = _read_exactly(stream, reason_len).decode()
        return cls(success, reason)


@dataclass(frozen=True)
class ClientInit:
    """
    https://datatracker.ietf.org/doc/html/rfc6143#section-7.3.1

    Once the client and server agree on and perhaps validate a security
    type, the protocol passes to the initialization stage.  The client
    sends a ClientInit message.  Then, the server sends a ServerInit
    message.

    Shared-flag is non-zero (true) if the server should try to share the
    desktop by leaving other clients connected, and zero (false) if it
    should give exclusive access to this client by disconnecting all
    other clients.

              +--------------+--------------+--------------+
              | No. of bytes | Type         | Description  |
              +--------------+--------------+--------------+
              | 1            | U8           | shared-flag  |
              +--------------+--------------+--------------+
    """

    shared: bool  # u8

    _STRUCT: ClassVar[Struct] = Struct("B")

    @classmethod
    def read_from(cls, stream: IO[bytes]) -> Self:
        (shared,) = _unpack_stream(cls._STRUCT, stream)
        return cls(shared != 0)

    def write_to(self, stream: IO[bytes]) -> None:
        stream.write(self._STRUCT.pack(self.shared))


@dataclass(frozen=True)
class ServerInit:
    """
    https://datatracker.ietf.org/doc/html/rfc6143#section-7.3.2

    After receiving the ClientInit message, the server sends a ServerInit
    message.  This tells the client the width and height of the server's
    framebuffer, its pixel format, and the name associated with the
    desktop:

      +--------------+--------------+------------------------------+
      | No. of bytes | Type [Value] | Description                  |
      +--------------+--------------+------------------------------+
      | 2            | U16          | framebuffer-width in pixels  |
      | 2            | U16          | framebuffer-height in pixels |
      | 16           | PIXEL_FORMAT | server-pixel-format          |
      | 4            | U32          | name-length                  |
      | name-length  | U8 array     | name-string                  |
      +--------------+--------------+------------------------------+

    Server-pixel-format specifies the server's natural pixel format.
    This pixel format will be used unless the client requests a different
    format using the SetPixelFormat message (Section 7.5.1).
    """

    screen_width: int  # u16
    screen_height: int  # u16
    pixel_format: PixelFormat
    name: str

    _STRUCT_SCREEN_SIZE: ClassVar[Struct] = Struct("!HH")
    _STRUCT_NAME_LENGTH: ClassVar[Struct] = Struct("!I")

    @classmethod
    def from_bytes(cls, message: IO[bytes]) -> Self:
        (width, height) = _unpack_stream(cls._STRUCT_SCREEN_SIZE, message)
        pixel_format = PixelFormat.from_bytes(message)

        (name_len,) = _unpack_stream(cls._STRUCT_NAME_LENGTH, message)
        name = _read_exactly(message, name_len).decode("iso-8859-1")

        return cls(width, height, pixel_format, name)


@dataclass(frozen=True)
class PixelFormat:
    """
    https://datatracker.ietf.org/doc/html/rfc6143#section-7.4

    Several server-to-client messages include a PIXEL_FORMAT, a 16-byte
    structure that describes the way a pixel is transmitted.

             +--------------+--------------+-----------------+
             | No. of bytes | Type [Value] | Description     |
             +--------------+--------------+-----------------+
             | 1            | U8           | bits-per-pixel  |
             | 1            | U8           | depth           |
             | 1            | U8           | big-endian-flag |
             | 1            | U8           | true-color-flag |
             | 2            | U16          | red-max         |
             | 2            | U16          | green-max       |
             | 2            | U16          | blue-max        |
             | 1            | U8           | red-shift       |
             | 1            | U8           | green-shift     |
             | 1            | U8           | blue-shift      |
             | 3            |              | padding         |
             +--------------+--------------+-----------------+

    Bits-per-pixel is the number of bits used for each pixel value on the
    wire.  This must be greater than or equal to the depth, which is the
    number of useful bits in the pixel value.  Currently bits-per-pixel
    must be 8, 16, or 32.  Big-endian-flag is non-zero (true) if multi-
    byte pixels are interpreted as big endian.  Although the depth should
    be consistent with the bits-per-pixel and the various -max values,
    clients do not use it when interpreting pixel data.

    If true-color-flag is non-zero (true), then the last six items
    specify how to extract the red, green, and blue intensities from the
    pixel value.  Red-max is the maximum red value and must be 2^N - 1,
    where N is the number of bits used for red.  Note the -max values are
    always in big endian order.  Red-shift is the number of shifts needed
    to get the red value in a pixel to the least significant bit.  Green-
    max, green-shift, blue-max, and blue-shift are similar for green and
    blue.  For example, to find the red value (between 0 and red-max)
    from a given pixel, do the following:

    o  Swap the pixel value according to big-endian-flag, e.g., if big-
       nendian-flag is zero (false) and host byte order is big endian,
       then swap.

    o  Shift right by red-shift.

    o  AND with red-max (in host byte order).

    If true-color-flag is zero (false), then the server uses pixel values
    that are not directly composed from the red, green, and blue
    intensities, but serve as indices into a color map.  Entries in the
    color map are set by the server using the SetColorMapEntries message
    """

    bits_per_pixel: int = 32  # u8
    depth: int = 24  # u8
    bigendian: bool = False  # u8
    truecolor: bool = True  # u8
    redmax: int = 255  # u16
    greenmax: int = 255  # u16
    bluemax: int = 255  # u16
    redshift: int = 0  # u8
    greenshift: int = 8  # u8
    blueshift: int = 16  # u8

    STRUCT: ClassVar = Struct("!BB??HHHBBBxxx")

    def __post_init__(self) -> None:
        assert self.bits_per_pixel in {8, 16, 24, 32}, f"bits_per_pixel={self.bits_per_pixel}"
        assert 1 <= self.depth <= self.bits_per_pixel, (
            f"depth={self.depth} <= bits_per_pixel={self.bits_per_pixel}"
        )
        if self.truecolor:
            for max, shift in zip(
                (self.redmax, self.greenmax, self.bluemax),
                (self.redshift, self.greenshift, self.blueshift),
            ):
                assert 1 <= max <= 0xFFFF, f"1 <= max={max} <= 0xffff"
                assert max & (max + 1) == 0, f"max={max} not a 2**n-1"
                assert 0 <= shift <= self.bits_per_pixel - max.bit_length(), (
                    f"shift={shift} not in bits_per_pixel={self.bits_per_pixel}"
                )

    def bytes_per_pixel(self) -> int:
        return (7 + self.bits_per_pixel) // 8

    @classmethod
    def from_bytes(cls, message: IO[bytes]) -> Self:
        return cls(*_unpack_stream(cls.STRUCT, message))

    def to_bytes(self) -> bytes:
        return PixelFormat.STRUCT.pack(
            self.bits_per_pixel,  # u8
            self.depth,  # u8
            self.bigendian,  # u8
            self.truecolor,  # u8
            self.redmax,  # u16
            self.greenmax,  # u16
            self.bluemax,  # u16
            self.redshift,  # u8
            self.greenshift,  # u8
            self.blueshift,  # u8
        )


class SecurityType(Enum):
    """
    Represents different security types in the RFB protocol.
    """

    INVALID = 0
    NONE = 1
    VNC_AUTHENTICATION = 2
    REALVNC_3 = 3
    REALVNC_4 = 4
    RSA_AES = 5
    RSA_AES_UNENCRYPTED = 6
    REALVNC_7 = 7
    REALVNC_8 = 8
    REALVNC_9 = 9
    REALVNC_10 = 10
    REALVNC_11 = 11
    REALVNC_12 = 12
    RSA_AES_2STEP = 13
    REALVNC_14 = 14
    REALVNC_15 = 15
    TIGHT = 16
    ULTRA = 17
    TLS = 18
    VENCRYPT = 19
    SASL = 20
    MD5 = 21
    XVP = 22
    SECURE_TUNNEL = 23
    INTEGRATED_SSH = 24
    DIFFIE_HELLMAN = 30
    APPLE_31 = 31
    APPLE_32 = 32
    APPLE_33 = 33
    APPLE_34 = 34
    APPLE_35 = 35
    MSLOGON2 = 113
    REALVNC_128 = 128
    RSA_AES256 = 129
    RSA_AES256_UNENCRYPTED = 130
    REALVNC_131 = 131
    REALVNC_132 = 132
    RSA_AES256_2STEP = 133
    REALVNC_134 = 134
    REALVNC_192 = 192

    @classmethod
    def read_from(cls, message: IO[bytes]) -> Self:
        return cls(_read_exactly(message, 1)[0])

    def write_to(self, stream: IO[bytes]) -> None:
        stream.write(Struct("B").pack(self.value))


class Encoding(Enum):
    """
    Represents different encoding types used in the RFB protocol.
    """

    @staticmethod
    def s32(value: int) -> int:
        return value - 0x1_0000_0000 if value >= 0x8000_0000 else value

    RAW = 0
    COPY_RECTANGLE = 1
    RRE = 2
    CORRE = 4
    HEXTILE = 5
    ZLIB = 6
    TIGHT = 7
    ZLIBHEX = 8
    ULTRA = 9
    ULTRA2 = 10
    TRLE = 15
    ZRLE = 16
    HITACHI_ZYWRLE = 17
    H264 = 20
    JPEG = 21
    JRLE = 22
    OPEN_H264 = 50
    APPLE_1000 = 1000
    APPLE_1001 = 1001
    APPLE_1002 = 1002
    APPLE_1011 = 1011
    REAL_1024 = 1024  # ... 1099
    APPLE_1100 = 1100
    APPLE_1101 = 1101
    APPLE_1102 = 1102
    APPLE_1103 = 1103
    APPLE_1104 = 1104
    APPLE_1105 = 1105
    TIGHT_1 = -1  # ... -22
    JPEG_23 = -23
    JPEG_24 = -24
    JPEG_25 = -25
    JPEG_26 = -26
    JPEG_27 = -27
    JPEG_28 = -28
    JPEG_29 = -29
    JPEG_30 = -30
    JPEG_31 = -31
    JPEG_32 = -32
    TIGHT_33 = -33  # ... -218
    LIBVNCSERVER_219 = -219  # historical
    LIBVNCSERVER_220 = -220  # historical
    LIBVNCSERVER_221 = -221  # historical
    LIBVNCSERVER_222 = -222  # historical
    PSEUDO_DESKTOP_SIZE = -223
    PSEUDO_LAST_RECT = -224
    POINTER_POS = -225
    TIGHT_226 = -226  # ... -238
    PSEUDO_CURSOR = -239
    PSEUDO_X_CURSOR = -240
    TIGHT_241 = -241  # ... -246
    PSEUDO_COMPRESSION_LEVEL_247 = -247
    PSEUDO_COMPRESSION_LEVEL_248 = -248
    PSEUDO_COMPRESSION_LEVEL_249 = -249
    PSEUDO_COMPRESSION_LEVEL_250 = -250
    PSEUDO_COMPRESSION_LEVEL_251 = -251
    PSEUDO_COMPRESSION_LEVEL_252 = -252
    PSEUDO_COMPRESSION_LEVEL_253 = -253
    PSEUDO_COMPRESSION_LEVEL_254 = -254
    PSEUDO_COMPRESSION_LEVEL_255 = -255
    PSEUDO_COMPRESSION_LEVEL_256 = -256
    PSEUDO_QEMU_POINTER_MODTION_CHANGE = -257
    PSEUDO_QEMU_EXTENDED_KEY_EVENT = -258
    PSEUDO_QEMU_AUDIO = -259
    TIGHT_PNG = -260
    PSEUDO_QEMU_LED_STATE = -261
    QEMU_262 = -262  # ...-272
    VMWARE_273 = -273  # ... -304
    PSEUDO_GII = -305
    POPA = -306
    PSEUDO_DESKTOP_NAME = -307
    PSEUDO_EXTENDED_DESKTOP_SIZE = -308
    PSEUDO_XVO = -309
    OLIVE_CALL_CONTROL = -310
    CLIENT_REDIRECT = -311
    PSEUDO_FENCE = -312
    PSEUDO_CONTINUOUS_UPDATES = -313
    PSEUDO_CURSOR_WITH_ALPHA = -314
    PSEUDO_JPEG_FINE_GRAINED_QUALITY_LEVEL = -412  # ... -512
    CAR_CONNECTIVITY_523 = -523  # ... -528
    PSEUDO_JPEG_SUBSAMLING_LEVEL = -763  # ... -768

    VA_H264 = s32(0x48323634)
    VMWARE_0X574D5600 = s32(0x574D5600)  # ... 0x574d56ff
    PSEUDO_VMWARE_CURSOR = s32(0x574D5664)
    PSEUDO_VMWARE_CURSOR_STATE = s32(0x574D5665)
    PSEUDO_VMWARE_CURSOR_POSITION = s32(0x574D5666)
    PSEUDO_VMWARE_KEY_REPEAT = s32(0x574D5667)
    PSEUDO_VMWARE_LED_STATE = s32(0x574D5668)
    PSEUDO_VMWARE_DISPLAY_MODE_CHANGE = s32(0x574D5669)
    PSEUDO_VMWARE_VIRTUAL_MACHINE_STATE = s32(0x574D566A)
    PSEUDO_EXTENDED_CLIPBOARD = s32(s32(0xC0A1E5CE))
    PLUGIN_STREAMING = s32(0xC0A1E5CF)
    KEYBOARD_LED_STATE = s32(0xFFFE0000)
    SUPPORTED_MESSAGES = s32(0xFFFE0001)
    SUPPORTED_ENCODINGS = s32(0xFFFE0002)
    SERVER_IDENTITY = s32(0xFFFE0003)
    LIBVNCSERVER_0XFFFE0004 = s32(0xFFFE0004)  # ... 0xfffe00ff
    CACHE = s32(0xFFFF0000)
    CACHE_ENABLE = s32(0xFFFF0001)
    XOR_ZLIB = s32(0xFFFF0002)
    XOR_MONO_RECT_ZLIB = s32(0xFFFF0003)
    XOR_MULTI_COLOR_ZLIB = s32(0xFFFF0004)
    SOLID_COLOR = s32(0xFFFF0005)
    XOR_ENABLE = s32(0xFFFF0006)
    CACHE_ZIP = s32(0xFFFF0007)
    SOL_MONO_ZIP = s32(0xFFFF0008)
    ULTRA_ZIP = s32(0xFFFF0009)
    SERVER_STATE = s32(0xFFFF8000)
    ENABLE_KEEP_ALIVE = s32(0xFFFF8001)
    FTP_PROTOCOl_VERSION = s32(0xFFFF8002)
    SESSION = s32(0xFFFF8003)

    @classmethod
    def read_from(cls, stream: IO[bytes]) -> Self:
        return cls(_read_exactly(stream, 1)[0])


def _read_exactly(stream: IO[bytes], num_bytes: int) -> bytes:
    """
    Reads an exact number of bytes from a stream.
    """
    value = stream.read(num_bytes)
    if len(value) != num_bytes:
        raise EOFError(
            f"Stream is too short, tried to read {num_bytes} bytes, only got {len(value)} {value=}"
        )
    return value


def _unpack_stream(pattern: Struct, stream: IO[bytes]) -> tuple[Any, ...]:
    """
    Unpacks data from a stream according to a given pattern.
    """
    return pattern.unpack(_read_exactly(stream, pattern.size))
